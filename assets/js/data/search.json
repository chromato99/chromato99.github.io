[ { "title": "2022 오픈소스 컨트리뷰션 아카데미 Challenges 후기", "url": "/posts/2022-%EC%98%A4%ED%94%88%EC%86%8C%EC%8A%A4-%EC%BB%A8%ED%8A%B8%EB%A6%AC%EB%B7%B0%EC%85%98-%EC%95%84%EC%B9%B4%EB%8D%B0%EB%AF%B8-Challenges-%ED%9B%84%EA%B8%B0/", "categories": "Activity, OSSCA2022", "tags": "ossca2022, yorkie", "date": "2022-08-19 19:49:00 +0900", "snippet": "평소 여러 오픈소스 소프트웨어를 사용하면서 여러 사람이 함께 참여하는 오픈소스 방식에 매력을 느끼게 되었다. 특히, 기술은 공유 할 수록 더 발전할 수 있다는 자유 소프트웨어 정신이 좋기도 하였고 좋은 소프트웨어를 개발해준 오픈소스 커뮤니티들에 대한 감사함도 있었다.그러면서 자연스럽게 나도 오픈소스 개발에 기여해보고 싶다는 생각을 하게되었다. 하지만 선뜻 오픈소스 개발에 뛰어들기에는 망설여졌는데, 아직 학생이라 실력이 부족한 건 아닐까 생각하기도 하였고 오픈소스 커뮤니티가 어떤 식으로 운영되는지에 대해서도 잘 몰랐기 때문이다.그러던중 멘토의 도움을 받으며 오픈소스 기여활동을 하는 오픈소스 컨트리뷰션 아카데미에 대해 알게 되었고 오픈소스 개발에 참여해보는 좋은 기회가 될것 같아 신청을 결심하게 되었다.아카데미 지원 (프로젝트 소개)Yorkie오픈소스 컨트리뷰션 아카데미에는 25개의 오픈소스 프로젝트가 있고 이중에서 기여해보고 싶은 프로젝트에 지원하는 방식으로 신청을 하게 된다. 따라서 1,2 지망을 골라 지원해야 하는데 나는 1지망 Yorkie, 2지망 Backend.AI를 골라 지원하였고 Yorkie에 붙어 활동하게 되었다!1지망으로 지원한 Yorkie는 실시간 협업 애플리케이션 개발을 위한 분산 시스템과 SDK를 개발하는 프로젝트로 컨트리뷰션 아카데미 프로젝트 소개를 읽고 처음 알게되었다. Yorkie를 처음 보자마자 매우 큰 관심을 갖게 되었는데, 이전부터 백엔드 서버 개발과 분산 시스템에 대해 관심을 갖고 공부하고자 노력했었고 최근 Go언어에 관심이 생겨 공부하기 시작했는데 마침 Yorkie 서버가 Go언어를 사용해 구현되었기 때문이다. 그리고 Yorkie 데모를 테스트 하면서 매우 빠른 반응속도를 보고 더욱 흥미를 갖게 되었다.하지만 기존에 주력으로 사용하던 것은 Node.js와 자바스크립트였고 Go언어는 비교적 최근에 시작해서 아직 부족하다 생각해 망설여 지기도 하였다. 그리고 아카데미 후기를 찾아보니 이미 현업에서 일하시는 분들도 많이 지원한다는 것을 보고 아직 학부 3학년인 내가 해낼 수 있을까 걱정이 들기도 했다.그렇지만 오픈소스 기여를 해볼 수 있는 좋은 기회를 놓치기 아깝다 생각하였고 지원 시기와 실제 활동기간 사이에 긴 텀이 있어 이때 많은 공부를 하며 준비를 하기로 마음 먹었다. 그리고 실제로 이 기간동안 WiFi Positioning Server 작업을 Go언어로 포팅을 하면서 공부를 했다.Openstack, Backend.AI다음으로 Yorkie를 제외하고도 Openstack과 Backend.AI에도 관심이 갔었다.특히 Openstack은 대학교 1학년때 Openstack 커뮤니티에 속한 연사분의 초청강의를 들어본적이 있기도 하였고 가상화와 분산 시스템에 매우 많은 관심이 있었기 때문이다. 특히 가상화 기술을 사용한 인프라 구축에대해 공부하고 싶다고 생각하였다. 하지만 아직 많은 공부를 해본것이 아니라 기반 지식이 부족하다고 생각하였고 Openstack 개발에 사용되는 Python에 대한 깊은 이해가 없어 지원을 보류하게 되었다. 만약 후에 기회가 된다면 반드시 오픈스택에 대해 공부하고 더 나아가 기여 또한 해보고 싶다.Backend.AI의 경우 AI 백엔드 플랫폼을 개발하는 프로젝트이다. 플랫폼 시스템의 구조와 그 구현에 대해 공부하고 싶었기 때문에 Backend.AI 또한 프로젝트 소개에서 보자마자 관심을 갖게 되었다. 무엇보다 최근 시작한 졸업작품 프로젝트가 사진 업스케일링 플랫폼을 개발하는것을 주제로 선정했기 때문에 딥러닝을 통한 이미지 업스케일링을 공부하기 시작하면서 AI 백엔드 플랫폼이라는것이 흥미롭다고 생각했다. 따라서 Yorkie와 조율하다 최근 Go언어에 관심이 쏠리면서 2지망으로 지원하게 되었다.발대식Yorkie 팀의 발대식은 7월 9일 토요일에 온오프라인으로 동시에 진행되었다.나는 오프라인으로 발대식에 참여했는데 장소는 선릉역 근처의 저스트코타워였다.건물에 도착한뒤 출석을 체크하고 기념품과 다과를 받고 Yorkie팀의 세미나실로 이동하였다. 기념품으로 에코백과 충전기 등을 받았고 샌드위치와 쿠키, 음료수 또한 받았다!(기념품을 사진으로 남겼어야 했는데 까먹었다ㅠㅜ)발대식은 30분 정도 진행됬던걸로 기억하고 아이스브레이킹을 위한 간단한 게임들도 같이 진행하였다. 아카데미 발대식 이후에는 팀별 발대식을 진행하였고 Yorkie 프로젝트에 대한 소개와 질답 시간을 가졌다. 팀별 발대식에서 Yorkie 프로젝트의 일부분인 Codepair를 사용해 동시편집을 하며 내용을 정리하였는데 이렇게 실제 사용되는 프로젝트에 기여할 생각을 하니 왠지 가슴이 벅차기도 했다ㅎ발대식이 진행된 뒤에는 모두 같이 기념사진을 촬영한뒤 해산하였다.기본 Git 교육본격적인 컨트리뷰션 활동에 앞서 주최측에서 기본 Git 사용법에 대한 교육을 진행하였다. 교육은 총 2회 진행되었는데 둘의 내용은 같아 시간이 되는 회차에 참가하면 되는 방식이었다. 나는 발대식 바로 다음날인 7월 10일에 참여 하였고 오전 9시부터 오후 18시까지로 오전에는 기초를 배우고 오후에는 응용과 실습을 진행하였다.내용은 처음에는 git 명령인 status, add, commit, push, pull, log 등에 대해 알아보았고 다음으로 협업을 위한 branch, checkout, remote, pull request 등에 대해 배올 수 있었다. 그런다음 이러한 브랜치를 관리하기위해 fetch를 사용해 원격지 업데이트 내용을 불러오고 merge, rebase 등을 하며 conflict를 해결하는 방법에 대해 배웠다. 마지막으로 reset, rebase -i 등과 같은 심화 기능을 배운뒤 git blame과 같이 과거 기록을 조회해 프로젝트 구조나 구현 의도를 파악하는 방법을 배울 수 있었다.기존에도 팀 프로젝트 등을 진행하면서 어느정도 Github과 Git에 대한 사용법을 알고 있었지만 이번 교육을 통해 상세한 사용법과 실제 오픈소스 개발 과정에서의 개발 흐름에 대한것까지 배울 수 있었다. 특히, 오픈소스 프로젝트를 파악하는 여러 꿀팁과 경험에 대해 배울 수 있었고 실제 프로젝트 개발의 과정과 소통의 과정, 코드 리뷰 과정에 대해 알 수 있게된 너무 소중한 시간이었다. 다른 사람에게도 오픈소스 컨트리뷰션 아카데미에 참여한다면 꼭 기본 교육을 수강하라고 추천하고 싶었다.Challenges 기간기본교육이 끝나고 Challenges 기간이 시작 되었다. 오픈소스 컨트리뷰션 아카데미는 크게 두개의 기간을 가지고 진행되는데 challenges 기간과 masters 기간이 그것이다. 그 사이에는 중간발표가 있고 마지막에는 최종발표가 있다. Masters 기간은 Challenges 기간의 활동을 바탕으로 선발되어야 이어서 진행할 수 있다.Challenges 기간이 시작되면서 Yorkie 팀은 멘티를 크게 3팀으로 나눠 진행하기로 하였고 R,G,B 3개의 팀으로 나누게 되었다. 그리고 모든 소통은 Slack을 기반으로 진행하기로 하며 Yorkie Slack에 초대되었고 활동을 시작하게 되었다.본격적인 기여에 앞서 우선 Yorkie 프로젝트의 구현을 이해하기 위해 노력했다. Yorkie의 문서를 열심히 읽어보았고 gRPC에 대해 기존에 사용해본적이 없어 예제 코드를 제작하면서 공부를 하였다. 그리고 Yorkie의 개발환경을 구성하고 데모를 테스트해보는 시간을 가지며 여러 이슈들과 PR의 내용을 확인하며 기여를 해볼 수 있는 부분을 찾아보았다.첫 이슈 선점 - Add --backend-snapshot-with-purging-changes flag #288이슈 링크: https://github.com/yorkie-team/yorkie/issues/288그렇게 열심히 공부하던중 한 이슈에 관심이 가기 시작했고 마침 메인테이너께서 Good First Issue 라벨을 달아두셨길래 드디어 처음으로 이슈를 선점하는 코멘트를 달게되었다.이슈에 대해 설명하자면 현재 yorkie의 구현은 모든 변경사항(change)들을 하도 빠짐없이 저장하는 방식이다. 하지만 이는 많은 저장공간을 차지하게 되기도 하고 yorkie에는 이미 특정 버전의 document를 저장하는 snapshot이라는 기능이 구현되어 있기도 하므로 이를 활용해 snapshot이 저장될때 이전의 change들을 삭제하는 옵션을 추가하자는 제안이었다.이 이슈를 확인하면서 snapshot이 생성될때 단순히 DB에서 change들을 일괄 삭제하는 간단한 작업만 추가하면 될것이라 생각하였고 호기롭게 이슈를 선점하고 개발을 시작하였다..(이때는 아직 엄청난 난관이 있을줄은 몰랐다..)첫 이슈 - example/index.js stops when receiving a snapshot from the server. #347그렇게 열심히 개발에 몰입하던 중 이상한점을 발견하게 되는데 이를 통해 처음으로 issue를 생성하게 되었다.첫 이슈: https://github.com/yorkie-team/yorkie-js-sdk/issues/347이상한 점은 바로 프론트에서 서버와 통신하며 수정 사항을 동기화 할때 change 자료형이 아닌 snapshot 자료형으로 수정사항을 전달받으면 작동이 멈추는 문제였다. 처음에는 위의 이슈를 개발하고 있었으니 내가 개발한 부분에서 문제가 생기는줄 알고 계속 코드를 수정하며 테스트 했는데 도저히 고쳐지지 않아 많은 고민을 하고 있었다. 그러다 번뜩 버그일 수도 있다는 생각을 하였고 테스트를 해보니 버그인것 같아 이슈를 써보기로 생각했다.이렇게 발견한 버그에 대해 계속 테스트하며 재현 방법을 확인해 보았고 상세히 첫 이슈를 작성해 보게 되었다. 현재는 버그가 수정되어 이슈가 Closed 되었다.첫 PR - Add --backend-snapshot-with-purging-changes flag #370첫 PR: https://github.com/yorkie-team/yorkie/pull/370위에서 이슈를 선점한뒤 개발을 시작했는데 그 과정은 생각보다 쉽지 않았다..우선 새로운 플래그가 추가되어야 하니 Yorkie에서 CLI 구현을 위해 사용한 Cobra 라이브러리를 공부해 --backend-snapshot-with-purging-changes 플래그를 추가해 주었다. 이를 위해 /server/backend/config.go에 SnapshotWithPurgingChanges 변수도 추가해 주었다.그런다음 /server/packs/snapshot.go의 storeSanpshot 함수와 /server/backend/database의 코드들을 수정해 snapshot이 생성될때 change들을 삭제하는 코드를 추가했다. 그리고 제대로 작동하는지 확인하기 위해 계속 테스트를 진행해 보았고 몇가지 문제를 발견하게 되었다.첫번째는 위에서 적은 버그를 발견한 것이었다! 처음으로 오픈소스 프로젝트의 버그를 발견한 것이었고 열심히 버그를 확인한 뒤 떨리는 마음으로 첫 이슈를 작성하게 되었다.두번째는 change를 삭제하도록 했더니 SyncedSeqs를 기록하는 부분에서 문제가 생긴것이다. 처음에는 단순히 change만 삭제하면 될줄 알았는데 change가 삭제되면 에러가 나는 부분이 있던것이다. 이를 해결하기 위해 처음에는 유심히 확인하지 않았던, 동기화가 일어날때 마지막으로 동기화하는 지점을 기록하는 SyncedSeqs와 관련된 코드를 열심히 확인하였다.그 결과 문제를 찾을 수 있었는데, UpdateSyncedSeq 함수에서 SyncedSeq가 기록된 테이블을 업데이트 할때 해당 ServerSeq의 change를 호출하는 부분이 있던 것이다. 원인을 찾고 고민 끝에 동기화가 일어나기 전의 change는 삭제하면 안된다고 생각하였고 snapshot을 생성할때 change를 일괄 삭제하는 것이 아닌 SyncedSeq 테이블에 기록된 동기화가 끝난 change들만 삭제하도록 변경하였다.이렇게 수정을 하고 테스트를 했더니 크게 문제가 없는것 같아 개발이 완료되었다고 생각했고, PR을 생성하기로 했다.하지만 의기양양하게 PR을 열었지만 무수한 코멘트를 받게 되고 생각보다 많은 문제에 직면하게 된다..Add --backend-snapshot-with-purging-changes flag #370 코드 리뷰PR을 생성하고 시간이 조금 지나서 mainter 분께서 코멘트를 달아 주셨다. 코멘트는 간단한 이야기였는데 history 명령을 실행할때도 문제가 없냐는 부분이었다.이는 개발을 하면서 간과했던 부분이었는데, 내가 위 플래그를 개발시작하기 불과 얼마전에 새롭게 change들을 조회하는 history 명령이 업데이트 되었는데 이를 간과한 것이었다..빠르게 수정작업을 시작하였고 admin 관련 cli 부분을 모두 확인하느라 쉽지 않았다. 특히 기존의 구현은 모든 change가 존재하는것을 전제로 해서 그런지 상당히 많은 부분을 수정해야 할것 같았고 최대한 원래 코드를 건드리지 않으면서 change가 삭제된 경우를 예외처리 하기 위해 노력했다.결국 gRPC를 위한 proto파일까지 수정해 프로토콜에 대한 변경사항까지 추가해야 했다.이렇게 history 명령에 대한 부분은 해결해서 푸쉬하였지만 아직 더 수정할 부분이 있었는데, 바로 test 코드를 간과한 것이었다. 평소 작은 규모의 과제 정도에서는 테스트 코드까지 작성해 테스트를 자동화 하며 테스트할 일이 없었다. 하지만 이정도의 큰 규모의 프로젝트에서는 모든 기능 하나하나에대한 테스트 코드를 작성하며 개발을 해야한다.나는 평소 간과하고 있던 테스트에 대해 다시 깨달으며 Go언어에서 테스트 코드를 작성하는 방법을 공부하고 테스트를 만드는 작업을 시작했다.처음에는 간단하게 예외처리만을 추가한 테스트를 생각하다가 이걸로는 부족하다 생각해 --backend-snapshot-with-purging-changes 플래그가 있을때 change가 제대로 삭제되는지, history 명령은 제대로 작동하는지 테스트를 작성했다. 이 과정에서 자료형과 관련해서 일관성이 부족한 문제를 확인할 수 있었고 이는 따로 분리해서 다루는게 좋다고 생각해 따로 이슈를 생성하였다. 이에대한 것은 아래에 자세히 서술했다.이제 테스트도 작성했겠다 이제 개발이 완료되었다고 생각하던 때에 작업한 테스트를 푸쉬했더니 또다른 문제가 생겼다.문제는 나의 로컬 환경에서는 테스트가 성공하는데 테스트를 푸쉬한뒤 github actions의 CI툴이 자동으로 테스트가 수행되면 테스트에 실패하는 것이었다.이 문제는 나에게 상당한 멘붕을 느끼게 했다. 나의 로컬 환경에서는 재현이 안되는데 도저히 원인을 파악할 수 없었기 때문이다. 그래서 Yorkie Slack에 도움을 구해보기도 하고 문제 해결을 위해 계속 고민을 했다.그러다 문득 yorkie에서 snapshot을 생성할 때는 goroutine을 사용한다는 것이 기억났고 이 문제가 타이밍 문제라는 직감이 들었다. 바로 테스트 해봤고 명시적으로 긴시간을 sleep했더니 문제가 해결되는것을 확인할 수 있었다.추가로 몽키패치를 적용하는것이 좋겠다는 코멘트가 달렸고 처음으로 몽키패치가 뭔지에 대해 알 수 있었다.이외에도 구현에 대한 여러 코멘트를 주고 받았고 또 수정하는 작업을 했다.이처럼 생각보다 간단한 기능이라 생각했던것이 많은 코드를 수정해야 했고 많은 난관이 있었다. 아직 PR 또한 크리티컬한 부분을 많이 건드리기도 해서 메인으로의 merge는 보류 중이다.메인테이너 멘토께서도 많은 부분을 건드리는 만큼 구현에 대한 토론을 제의해 주셨고 이때 이 플래그 기능의 추가에 대한 의견을 좀 더 실시간으로 나눌수 있을것 같다.하지만 아직 개발이 완료된것은 아니어도 개발 과정에서 많은 것을 배울 수 있었다. 특히 새로운 기능을 추가할때는 이와 연관된 다른 기능들도 확인해야 하는것을 알 수 있었고, 코드 스타일을 주의해서 작성해야 한다는것도 느낄 수 있었다. 또한 테스트의 중요성을 다시한번 생각할 수 있었고 테스트를 위한 몽키패치와 같은 방법을 알 수 있었다.비록 기능 추가 자체가 보류될 수도 있다고 생각하지만 많은 것을 배울 수 있는 의미있는 시간이었다.두번째 이슈 및 PR - Change the data type of data inserted into the db from uint64 to int64 #379이슈 링크: https://github.com/yorkie-team/yorkie/issues/373PR 링크: https://github.com/yorkie-team/yorkie/issues/373이 이슈는 위의 이슈를 작업하다가 발견하게 되었다. 이슈의 내용은 mongodb는 정수를 int64 또는 int32로만 취급해서 uint64는 int64로 변환되어 저장된다는 것을 알게 된것이다. 이러한 사실을 코멘트로 의견을 교환했더니 메인테이너께서 이를 수정하는것을 제안해 주셨다. 왜냐하면 DB에 저장되는 데이터 타입과 서버에서 다루는 데이터 타입이 다른경우 개발에 혼동을 줄 수 있으니 데이터 타입 일관성을 위해 데이터 타입을 변경할 필요가 있기 때문이다.vscode의 검색 기능을 이용해 uint64 데이터 형중 DB에 삽입되는 데이터를 변환해 주었다. 작업 결과를 PR로 올렸고 메인테이너께서 그 사이에 생긴 업데이트로 인한 충돌 사항을 해결해 병합해 주셨다.작업 시작은 위의 이슈를 먼저 시작하였지만 어쩌다 보니 이것이 내가 기여한 첫 작업이 되었다!!!그리고 나도 드디어 contributor 칭호를 얻게 되었다 ^_^중간보고 및 Masters이것으로 Challenges 기간이 끝나게 되었다. 오픈소스 기여를 경험해볼 수 있는 정말 좋은 시간이었고 재미 또한 있었다고 생각한다. Challenges 기간이 끝나면 중간 활동 보고서를 작성해야 했기에 작성했고 Masters 기간은 선정된 멘티만 이어서 할 수 있기에 기다려야 했다.그렇게 Masters 기간 합격자 선정을 기다리고 있었는데 어느날 멘토분께 연락이 왔다. 연락은 바로 Masters 기간동안 리드멘티를 해볼 생각이 없냐는 제의 였다!!선뜻 리드멘티를 했다가 잘 할 수 있을까 고민도 되었지만, 리드멘티를 하기로 했다.리드멘티 중에 한명은 중간 발표회의 발표자가 되어 발표를 해야 한다. Yorkie 팀의 리드멘티는 나를 포함해 총 두명이었는데 slack DM을 통해 연락을 하였고 우선 중간 발표회는 다른 리드멘티분께서 발표를 하기로 하였다.그리고 중간 발표회를 위한 발표자료를 준비해야 했는데, 이는 같이 준비를 하기로 하였다. 서로 시간을 조율해 구글 미트로 같이 이야기하며 작업하기로 하였고 함께 발표자료를 작업하고 발표 스크립트를 준비했다.중간 발표회는 8월 13일에 있었고 이로써 Challenges 기간이 완전히 종료되고 Masters 기간이 시작되었다!" }, { "title": "스택 오버플로우 2022 설문", "url": "/posts/%EC%8A%A4%ED%83%9D-%EC%98%A4%EB%B2%84%ED%94%8C%EB%A1%9C%EC%9A%B0-2022-%EC%84%A4%EB%AC%B8/", "categories": "News and Trends, Programming", "tags": "programming treds, stack overflow 2022 survey", "date": "2022-07-05 14:49:00 +0900", "snippet": "https://survey.stackoverflow.co/2022/매년 진행하는 스택 오버플로우의 2022년 설문 결과가 공개되었습니다!개발에 대한 전반적인 인사이트를 얻는데 좋다고 생각합니다:)*다만 주로 영어권에서 진행된 조사인 만큼 국내 사정과는 조금 다를수 있습니다.주로 기술 관련된것 위주로 정리해 보았습니다.Most popular technology우선 가장 많이 사용되는 기술 통계입니다.이는 설문 응답자들이 사용하는 기술 스택들을 확인 할 수 있습니다.첫번째로 가장 많이 사용하는 프로그래밍 언어입니다!역시 최근에는 웹 기반 기술이 대세인 만큼 자바스크립트가 1등을 했습니다. 2등 또한 HTML/CSS네요.그 뒤로는 데이터베이스를 위한 SQL과 머신러닝을 비롯한 방대한 라이브러리가 뒷받침되는 파이썬이 3, 4등 이네요.자바스크립트의 대체제로 각광받는 타입스크립트도 많이 올라왔습니다.다음으로 데이터베이스 입니다. 전통의 강자 MySQL이 1등이고 최신 기술로 중무장로 것으로 인기를 얻고있는 PostgreSQL이 그뒤를 따르네요.Cloud Platform 조사입니다. 역시 AWS가 1등이고 파이어베이스를 포함해서 보면 구글도 상당한 지분을 차지하네요. 이전에는 2, 3등 격차가 꽤 컸던것으로 기억하는데 많이 따라잡힌 모습입니다.이것은 가장 많이 사용되는 웹프레임워크 조사입니다. 자바스크립트가 1등 언어였던 만큼 Node.js와 React.js가 최상위권을 차지하고 있습니다. 웹 프론트 3대장 React.js Vue.js Angular 중에서 React.js가 계속 유일 선두로 나아가고 있네요!이것은 웹 프레임워크를 제외한 기타 프레임워크 조사로 .NET이 1등을 차지한것을 볼 수 있습니다. 영미권에서는 C#이 상당히 많이 쓰인다는것을 확인할 수 있는것 같습니다. 또한 머신러닝과 딥러닝을 위한 여러 파이썬 라이브러리도 확인할 수 있네요!그리고 하이브리드 앱을 위한 프레임워크로 오차범위 내긴 하지만 Flutter가 React Native보다 근소 우위인것도 흥미롭네요.다음은 그외 기타 개발을 위한 도구들입니다. 역시 JavaScript가 1위인 만큼 JavaScript를 위한 패키지 메니저인 npm과 yarn이 상위권을 차지한 모습입니다. 가상 컨테이너 기술인 도커와 쿠버네티스도 매우 많이 사용하네요.게임에 한정된 조사가 아닌만큼 컴퓨터 산업 전체적으로 봤을때 유니티가 언리얼 엔진보다 광범위하게 쓰이는 모습도 흥미롭습니다.이것은 가장 많이 사용되는 개발 툴 조사입니다.역시 vscode의 대세는 굳건한것을 확인 할 수 있습니다.이것은 운영체제 사용 조사입니다.킹갓리눅스가 맥보다 많이 사용되네요^^Most loved technology다음은 가장 사랑하거나, 두렵거나, 가장 원하는 것을 투표한 조사입니다.이는 아직 현업에서 사용하거나 또는 아직 사용하지 않지만 가장 기대되거나 좋아하는 기술 스택을 확인할 수 있습니다.지금 당장은 아니지만 미래에 대세가 될 수 있는 기술에 대한 인사이트를 얻을 수 있을것 같네요!우선 프로그래밍 언어입니다.Rust가 가장 좋아하는 언어 1등에 뽑혔습니다.최근 C++사용은 불허했던 리누스 토르발즈가 리눅스 커널 개발에 Rust사용을 천명한 만큼 확실히 미래에 기대되는 언어인것 같습니다.토발즈 “리눅스, 내년엔 ‘러스트’ 언어도 품는다”다음은 데이터베이스입니다. 아직 MySQL이 많이 쓰이긴 하지만 많이 사랑받지는 못하는것을 확인할 수 있습니다(ㅋㅋ)새로 공부를 하는데에는 PostgreSQL이나 Redis, MongoDB를 알아보는것도 좋은 전략인것 같네요.클라우드 플랫폼 입니다. 좋아하는 순위와 사용률 순위가 비슷하네요.웹 프레임워크 순위입니다.함수형 언어 Elixir를 사용하는 Phoenix가 1등 입니다. 최근 함수형 프로그래밍 언어가 떠오르는 만큼 주목할 필요가 있는것 같습니다.그 뒤로 차세대 프론트엔드 프레임워크로 각광받는 Svelte가 2등입니다.3등은 Node.js의 개발자가 Node.js의 단점을 개선하기위해 새로 개발한 Dene가 차지했습니다.기타 다른 프레임워크, 라이브러리 입니다. Hugging Face Transformers라는 저도 잘은 모르지만 머신러닝 모델과 스크립트를 모아둔 모듈이 1등입니다. 2등은 Tidyverse라는 R언어 패키지가 차지했습니다.그리고 파이토치가 텐서플로우보다 훨씬더 사랑받는 모습을 확인 할 수 있습니다.기타 툴들 입니다. 역시 최근에 도커와 같은 컨테이너 기반 가상화 기술이 각광받는 모습을 확인 할 수 있습니다.마지막으로 개발 환경 순위입니다. 역시 갬성넘치는 Vim의 개선판 Neovim이 1등을 한것들 확인할 수 있습니다.Reference여기 까지 몇가지 항목만 뽑아 설문 결과를 알아보았습니다.모든 설문 결과는 원문 페이지에서 확인할 수 있습니다!https://survey.stackoverflow.co/2022/" }, { "title": "페도라 36에 Nvidia 드라이버 설치", "url": "/posts/%ED%8E%98%EB%8F%84%EB%9D%BC-36%EC%97%90-Nvidia-%EB%93%9C%EB%9D%BC%EC%9D%B4%EB%B2%84-%EC%84%A4%EC%B9%98/", "categories": "Linux, Installation and Configuration", "tags": "linux, fedora, configuration, nvidia", "date": "2022-07-01 11:00:00 +0900", "snippet": "최근 아치 리눅스를 사용하다 페도라를 설치해 보았다.페도라는 순수 오픈소스를 지향하는 배포판으로 기본 패키지에는 모두 오픈소스 패키지들만 설치되는데, 따라서 proprietary 소프트웨어인 Nvidia 그래픽 카드의 다리어버가 아닌 nouveau 드라이버가 설치된다.하지만 nouveau는 리버스 엔지니어링으로 만든 드라이버라 아직 불안정한 부분이 많아 공식 드라이버를 설치했는데, Secure Boot를 사용하는 환경에서는 몇가지 복잡한 과정이 있어 이를 정리해 놓고자 한다.RPM fusion Howto Nidia 문서Howto/Nvidia이 글은 위의 링크의 내용을 기반으로 작성하였다.Installing the drivers 문단을 보면 Secure Boot에 대한 경고가 한줄 있는 것을 확인할 수 있는데 이는 nvidia 드라이버 모듈을 설치하기 위해서는 셀프 서명한 Secure Boot Key가 있어야 한다는 내용이다.최근에는 윈도우 11의 Secure Boot 강제로인해 Secure Boot를 사용하는 환경이 보편화 되었으므로 이 경고 내용을 포함에 설치 방법을 작성했다.글을 작성할때 사용한 환경은 페도라 36 버전으로 이후 버전에서는 내용이 조금 달라질 수 있다.설치 방법1. Secure Boot Key 생성을 위한 패키지 설치sudo dnf install kmodtool akmods mokutil openssl위 명령어로 Secure Boot Key 생성을 위한 툴들을 설치해준다.2. Signing Key 생성sudo kmodgenca키 생성 명령어 이다.3. Linux kernel에 Key를 등록 준비sudo mokutil --import /etc/pki/akmods/certs/public_key.der위 명령을 입력하면 키를 등록할 준비를 하는 과정이다. 실제 키 등록은 아래에 재부팅 과정에서 진행된다.추가로 명령을 실행하면 비밀번호를 입력하라고 하는데 이는 아래에서 키를 등록할 때 다시 입력해야 하므로 기억해야 한다.4. 재부팅키 등록을 위해 재부팅을 해야한다.5. Key 등록재부팅을 하다보면 처음보는 파란 바탕의 MOK Manager가 실행되는데 이화면에서 등록을 진행해야 한다. 우선 Enter를 입력하면 메뉴창이 뜨는 것을 확인할 수 있다. 여기서 ‘Enroll MOK’을 방향키로 지정한뒤 Enter를 누른다. 다음 화면에서 ‘Continue’를 선택한다. 다음 화면에서 ‘Yes’를 선택한다. 위에서 설정한 비밀번호를 입력한다. ‘OK’를 선택한다. ‘reboot’를 선택한다.6. Nvidia 드라이버 설치이제 Nvidia 드라이버를 설치해 주면 된다.sudo dnf install akmod-nvidiasudo dnf install xorg-x11-drv-nvidia-cuda7. 재부팅이제 설치가 끝났다! 재부팅을 해주면 nvidia 드라이버가 로드된다.드라이버 로드 확인lsmod | grep nvidia위 명령으로 드라이버가 제대로 로드됬는지 확인할 수 있다.Referencehttps://rpmfusion.org/Howto/NVIDIAhttps://rpmfusion.org/Howto/Secure%20Boot" }, { "title": "Syncthing을 사용한 디렉터리 연동", "url": "/posts/Syncthing%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%9C-%EB%94%94%EB%A0%89%ED%84%B0%EB%A6%AC-%EC%97%B0%EB%8F%99/", "categories": "Linux, Installation and Configuration", "tags": "linux, configuration, syncthing", "date": "2022-06-30 11:00:00 +0900", "snippet": "평소 집에서는 데스크톱을 사용하고 밖에서는 노트북을 사용하여 개발 등의 작업을 하다 보니 이 두 기기간의 연동이 되어 작업 중이던 작업을 이어서 할 수 있으면 좋을 것 같다 생각하였다.따라서 두 기기간 연동되는 환경을 구축하기 위해 여러 방법에 대해 검색하였고 Nextcloud, rsync, lsync, sshfs 등의 방법 등을 사용해 보았었다. 결과적으로 현재는 syncthing을 사용하고 있는데 이에 대해 소개하고자 한다.SyncthingIntroductionSyncthing은 지속적인(continuous) 파일 동기화 프로그램으로 두 대 이상의 컴퓨터 간에 파일을 실시간으로 동기화해준다.오픈소스 프로그램으로 MPL 2.0 라이센스로 배포되며 멀티 플랫폼을 지원해 Windows, macOS, Linux, Android, Solaris, Darwin, BSD에서의 사용을 지원한다.또한 파일을 전송할 때에는 TLS를 사용한 암호화된 통신을 사용해 안전하게 데이터를 주고받을 수 있다고 한다.현재 사용중인 환경글쓴이의 경우 이 Syncthing을 사용해 데스크톱, 노트북, 그리고 개인 서버까지 3개의 기기를 연동해 사용 중이다.위에서는 데스크톱과 노트북 두 기기간의 연동을 위해 사용한다 해놓고 실제로는 개인 서버까지 3개를 사용하고 있는데 이는 개인 서버를 추가로 사용하면 좀 더 실사용에서 유용하기 때문이다.좀 더 자세히 설명하자면, Syncthing을 둘 또는 그 이상의 기기간의 디렉터리를 동기화해주는 프로그램으로 두 개의 기기를 동기화할 경우 두기기가 모두 켜져 있어야 실시간으로 동기화가 된다.따라서 두기기가 모두 켜져있지 않으면 동기화를 보류해 두었다 연결이 성공했을 때 동기화를 해주게 되는데, 이렇게 될 경우 한 기기에서 작업한 내용이 다른 기기에 반영하기 위해서는 잠깐이지만 두기 기를 둘 다 켜놓고 동기화가 끝나길 기다려야 한다.이렇게 될 경우 노트북에서 작업한 작업을 집에 들어와서 데스크톱을 켜서 작업할 때 노트북도 잠시 켜서 두기기가 모두 연결이 이루어지도록 해줘야 하는 불편함이 있었다.이를 해결하기 위해 24시간 켜 두는 개인 서버로 사용하는 라즈베리파이에도 syncthing을 설치해 사용하는 세팅을 하게 되었다.위와 같이 세팅을 해주게 되면 데스크톱과 노트북에서 파일을 수정하게 되면 24시간 켜져 있는 서버에 실시간으로 변경이 반영되므로 두 기기간의 동기화를 위해 두 기기를 동시에 켜둘 필요가 없어진다.또한 서버에 언제나 파일이 백업되므로 좀 더 안전한 파일 관리가 가능하다.그렇다면 이제 syncthing을 설치하고 설정하는 방법에 대해 알아보자.설치 및 설정설치Syncthing을 설치하기 위해서는 Syncthing 다운로드 문서를 참고해 자신의 운영체제나 환경에 맞게 설치를 진행해 주면 된다.설치가 끝나면 백그라운드에서 동작할 수 있게 아래 명령을 실행해준다.systemctl --user enable --now syncthing.service그러면 이제 백그라운드에서 syncthing이 실행중이게 되는데 설정을 위한 화면은 웹브라우저로 https://localhost:8384로 접속하면 된다.처음 브라우저로 접속하면 아래와 같은 경고를 볼 수 있다.이는 https 연결을 위한 ssl 인증서가 인증이 안되었다는 경고로 인터넷에서 알 수 없는 사이트를 들어갈 때는 조심해야 하지만 지금 들어가려는 페이지는 방금 서버를 열었기 때문에 인증이 없는 게 당연하므로 무시하고 접속하면 된다.처음 접속을 하면은 위와 같이 비밀번호를 설정하라는 안내가 나오는데 설정을 눌러 비밀번호를 설정하면 된다.그렇다면 이것으로 기본적인 설치는 끝난 것이다!기기연동 추가 및 동기화그렇다면 이제 기기간의 연동을 설정해 주어야 한다. 그러기 위해서는 우선 연동할 디렉터리(폴더)를 추가해주어야 한다.처음 기본 설정으로는 위의 부분에 기본적으로 추가된 디렉터리가 있을것인데 이를 사용해주어도 되고 아니면 연동하고 싶은 디렉터리(폴더)를 직접 추가해 주어도 된다.자신의 상황에 맞게 폴더를 설정했다면 연동하고 싶은 기기를 추가해야 하는데 위의 화면과 같이 기기가 추가되어야 한다.기기 추가를 위해서는 오른쪽 아래의 ‘다른 기기 추가’버튼을 누르면 된다.그러면 위와 같은 창이 뜨게 되는데 여기서 중요한 건 기기 식별자를 입력하는 것과 공유할 디렉터리(폴더)를 설정하는 것이다.우선 공유하고 싶은 디렉터리(폴더)는 원하는 것을 체크하면 되고 비밀번호는 자신의 기기인 것을 아는 이상 신뢰하는 기기이므로 입력하지 않아도 된다.다음으로 Syncthing은 각각의 기기에 고유한 문자열이 부여돼 이를 사용해 기기를 식별하게 되는데, 이러한 기기 식별자는 Sycthing 개발팀에서 운영하는 중앙 서버에 등록되어 세계 어디서나 기기의 IP가 변경되어도 식별자를 기준으로 IP를 연동하여 기기간 동기화를 가능하게 해 준다.따라서 기기 식별자를 입력해주어야 하는데 이는 아래와 같이 오른쪽 위 메뉴를 누르면 확인할 수 있다.기기 식별자는 내가 연동하고자 하는 대상의 기기 식별자를 입력해야 하므로 메신저 등을 사용해 복사해 입력해주도록 하면 된다.이렇게 설정을 모두 하면 대상이 되는 기기에서 기기를 추가하고 싶다고 알림이 오는것을 확인할 수 있다.위와 같은 알림이 오게되는데 알맞은 알림인지 확인하고 추가버튼을 누르면 된다.기기를 추가하면 좀 있다가 위와 같이 디렉터리(폴더)의 공유 요청이 들어오게 되고 이를 추가해주면 된다.이때 추가를 누르면 나오는 설정에서 기본 설정을 따라도 되지만 디렉터리 경로나 백업 설정 등을 할 수 있다. 이는 자신이 원하는대로 설정해주면 된다.설정이 끝나면 위와 같이 동기화중인 모습을 확인할 수 있다!이제부터는 파일에 변경 등이 있을때 실시간으로 다른기기에도 변경사항이 반영되는 것을 확인할 수 있다.추가 자료Syncthing을 실사용하면서 알게 된 한 가지 주의사항이 있는데, Syncthing의 경우 실시간 동기화이긴 하지만 동기화에 몇 초 정도의 시간이 걸리긴 하므로 가끔 동기화가 되기 전에 파일의 수정이 있으면 충돌이 일어나기도 한다.만약 파일 간에 충돌이 일어났다면 충돌 난 파일은 &lt;filename&gt;.sync-conflict-&lt;date&gt;-&lt;time&gt;-&lt;modifiedBy&gt;.&lt;ext&gt; 형식으로 파일이 기록되니 다시 교통정리를 해주면 된다.하지만 충돌이 일어나기 전에 동기화가 됐는지 잠깐 기다려서 확인한 뒤 사용하는 것이 좀 더 안전하지 않을까 한다..!여기까지 Syncthing의 간단한 설치 및 설정 방법이었다. 추가로 좀 더 syncthing을 잘 활용해보고 싶다면 공식 문서에 잘 정리되어 있으므로 확인해보면 좋을 것 같다." }, { "title": "리눅스 로그인 화면(GDM)에서 Auto Suspend 끄기", "url": "/posts/%EB%A6%AC%EB%88%85%EC%8A%A4-%EB%A1%9C%EA%B7%B8%EC%9D%B8-%ED%99%94%EB%A9%B4(GDM)%EC%97%90%EC%84%9C-auto-suspend-%EB%81%84%EA%B8%B0/", "categories": "Linux, Installation and Configuration", "tags": "linux, configuration, autosuspend, gdm, gnome", "date": "2022-06-12 10:00:00 +0900", "snippet": "리눅스로 세팅해둔 데스크탑을 원격 접속하기 위해 wake on lan 설정을 해두었는데 settings에서 auto suspend를 off 해도 컴퓨터가 절전모드로 들어가는 문제가 있었다.이를 어떻게 해결하면 될지 알아보고자 한다.Auto SuspendAuto Suspend 란 자동 절전모드로 컴퓨터를 일정시간 이상 사용하지 않으면 컴퓨터를 일시 중단해서 전력 소모량을 줄이는 기능이다.보통 Gnome의 경우 오른쪽 위에 메뉴창에서 Settings를 선택하면 설정창을 열 수 있다.여기서 Power 탭을 눌러 auto suspend 관련 설정을 바꿀 수 있다. 하지만 이는 Gnome 데스크탑 환경이 로그인 후 본격적으로 켜졌을때의 설정을 한것으로 그 이전에 그래픽 로그인 창을 띄워주는 디스플레이 매니저인 GDM 화면에서는 적용되지 않는다.보통 컴퓨터를 처음 키면 이 GDM 창이 나오게 되는데 원격으로 부팅했을 때는 그래픽 환경에서 로그인을 할 수 없으므로 컴퓨터가 일정시간이 지나면 절전모드로 들어가게 된다. 따라서, 이 GDM에서의 절전모드 설정을 바꿔주려 한다.GDM Auto Suspend 끄기GDM은 Settings창으로 설정 할 수 없기 때문에 터미널에서 명령어를 입력해줘야 한다.아치위키 내용에 따르면 아래 명령을 입력해주면 Auto Suspend를 아예 꺼버릴 수 있다고 한다.sudo -u gdm dbus-launch gsettings set org.gnome.settings-daemon.plugins.power sleep-inactive-ac-type 'nothing'Gnome Auto Suspend 설정을 가져오기단순히 auto suspend를 꺼버리는게 아니라 Gnome Settings에서 설정한 auto suspend 설정(꺼지는 시간 등)을 가져오고 싶을 수도 있다.그럴 때에는 아래 명령을 입력해서 Gnome Settings 설정을 가져와 적용할 수 있다고 한다.IFS=$'\\n'; for x in $(sudo -u username gsettings list-recursively org.gnome.settings-daemon.plugins.power); do eval \"sudo -u gdm dbus-launch gsettings set $x\"; done; unset IFS username은 설정을 가져오고 싶은 리눅스 유저명을 입력해 주면 된다.Referencehttps://wiki.archlinux.org/title/GDM" }, { "title": "Arch Linux 설치", "url": "/posts/Arch-Linux-%EC%84%A4%EC%B9%98/", "categories": "Linux, Installation and Configuration", "tags": "linux, arch linux, installation, boot, secure boot", "date": "2022-03-27 02:00:00 +0900", "snippet": "아치 리눅스는 리눅스 배포판 가운데 하나로 미니멀리즘과 빠른 업데이트로 유명하다.평소 리눅스를 공부하고자 리눅스를 메인 운영체제로 사용하기 위해 노력하는데, 최근 아치 리눅스에 정착해 사용중이다.다만 리눅스를 사용하다보면 이래저래 뻘짓을 하다보면 파일이 꼬이는 등의 문제가 생겨 클린 설치를 할 일이 생기는데 그럴때 참고하기위해 정리한 내용을 블로그 포스트로 써보고자 한다. 아치 리눅스의 공식 설치 가이드는 아치위키의 공식 Inastallation Guide 하나이므로 이를 중점적으로 참고하였다. 개인 참고용의 성격이 강하기 때문에 최대한 이유 등을 설명하기 위해 노력하겠지만 세부 설정 등이 글쓴이의 취향이 반영되어 있을 가능성이 높다.설치전 준비설치용 미디어 다운받기아치 리눅스 설치용 미디어는 아치리눅스 공식 홈페이지 위의 메뉴에서 다운로드 페이지에서 다운 받을 수 있다.토렌트로 다운받아도 되고 아래 HTTP 다운로드 링크에서 다운받을 수 있다. 글쓴이의 경우 한국 서버 주소에서 다운받는 편이다.설치용 미디어 만들기 (Windows)윈도우인 경우 Rufus를 사용해 설치용 usb를 만드는것이 편하다.최신 버전의 Rufus를 다운 받은뒤 장치에서 사용할 usb(포맷되니 주의!!)를 선택하고 선택 버튼을 눌러 위에서 다운받은 iso파일을 선택해준다.볼륨 레이블 이름은 적당히 입력하고 나머지는 기본으로 두고 시작 버튼을 누르면 된다!딱히 상관은 없지만 파티션 형식은 기본값인 MBR이 아닌 GPT(좀더 최신이다)로 선택해도 된다. 다만 GPT로 선택하면 UEFI 환경에서만 부팅 가능하다.설치용 미디어 만들기 (Linux)이미 리눅스 환경이라면 대부분 설치용 미디어를 만드는 법을 알고 있을 것이라 생각하지만 간단하게 서술해 보겠다.본인이 GNOME같은 데스크탑을 사용중이고 GNOME Image Writer 같은게 설치되어 있다면 이를 사용해도 된다.그것이 아니라면 터미널에서 명령어를 입력해도 된다. 아치위키의 USB flash installation medium 문서를 참고했다.우선 아래 명령어를 입력해 USB drive의 경로를 확인한다.lsblk그리고 해당 USB를 부팅용 USB로 만들기 위해서는 내용을 모두 지워줘야 하는 관계로 wipefs 명령을 입력한다. 디바이스 경로 (/dev/sdx)에서 x는 자신의 디바이스 경로로 입력해 주면 된다. 아래 명령어를 입력하면 USB의 모든 내용이 지워지므로 주의!!wipefs --all /dev/sdx구체적인 경로는 자신의 USB 장치에 맞게 입력해야 한다.그리고 마지막으로 아래 명령어를 입력하면 된다.cat ./archlinux-2022.03.01-x86_64.iso &gt; /dev/sdx혹시나 위의 명령이 permission denied가 뜰때는 아래처럼 입력하면 된다.sudo sh -c 'cat ./archlinux-2022.03.01-x86_64.iso &gt; /dev/sdx'만약 cat 명령이 아닌 cp나 dd를 사용하고 싶다면 USB flash installation medium 문서를 참고하자.USB 드라이브가 제대로 완성됬는지 확인하고 싶다면 fdisk 명령어로 확인해볼 수 있다.fdisk -l만들어진 USB 드라이브에 EFI 파티션이 만들어 졌다면 크게 문제 없을 것이다.Secure Boot 끄기 (optional)윈도우 11이 Secure Boot이 기본값으로 설정하게끔 하면서 많은 PC들은 Secure Boot이 켜져있는것이 기본값이 되고 있다.하지만 아치 리눅스 설치 미디어는 Secure Boot으로 부팅하는것을 지원하지 않기 때문에 자신의 컴퓨터가 Secure Boot이 켜져있다면 Bios 설정 창에 들어가 꺼주어야 한다.일단 설치 과정에서 임시로 Secure Boot을 끄는 것으로 다시 Secure Boot을 아치 리눅스와 함께 설정하는 것은 밑에서 다시 언급할 것이다.설치이제 부팅을 할 차례이다!! USB 설치 미디어를 삽입하고 부팅을 해보도록 하자.부팅이 완료되면 검은 화면의 터미널창이 반겨줄 것이다. 역시 미니멀리즘 배포판에게 GUI는 사치이다. 이제 차근차근 설치 단계를 밟아보도록 하자. 아치위키에서는 부팅후 키보드 레이아웃을 설정하라고 하지만 기본 설정인 US 키맵에서 한글키보드는 크게 문제가 없으니 생략했다.네트워크 연결처음 연결하면 네트워크가 연결 되어있는지 확인해야 한다. 아래 명령으로 네트워크 인터페이스가 제대로 인식되는지 확인할 수 있다.ip link아마 유선네트워크라면 자동으로 연결될 것이다. 아래 명령어로 제대로 네트워크에 접속되는지 확인할 수 있다.ping archlinux.org만약 와이파이를 사용해야하는 노트북등의 사용자라면 아래 설명을 따라 해주면 된다.Wi-Fi 연결 (optional)와이파이 연결은 iwctl 명령을 사용해 할 수 있다. 아래 과정대로 해주면 된다.# iwctl 프롬프트 창으로 바뀔것이다.iwctl# 명령어들을 확인할 수 있다.help# Wi-Fi 디바이스들을 확인 할 수 있다.device list# 주변 네트워크를 스캔한다.station &lt;device name&gt; scan# 주변 네트워크 리스트를 출력한다.station &lt;device name&gt; get-networks# Wi-Fi 네트워크에 연결한다.station &lt;device name&gt; connect &lt;SSID&gt;# iwctl 종료exit 위의 명령에서 &lt;&gt; 부분에는 자신에게 맞게 입력하면 된다.System clock 업데이트인터넷에 연결된것을 확인했으면 시스템 시간을 정확하게 업데이트 해줄 수 있다.timedatectl set-ntp true설정 상태 확인은 아래 명령어로 할 수 있다.timedatectl status리눅스 시스템 시간에 관련된 좀더 자세한 정보는 system time 문서에서 확인할 수 있다.System encryption 설정 (optional)시스템 전체를 암호화 하여 아치 리눅스를 설치하고자 하면 현재 단계에서 설정하면 된다.암호화에 대한 설명은 아치위키 dm-crypt 문서를 참고하면 된다.Partition 설정이제 파티션을 설정해 줘야 한다.이전에 EFI 파티션 설정에 대한 포스트를 쓴적이 있는데 이와 비슷하다.위에 링크에 들어가면 cfdisk로 파티션 설정하는 방법에 대한 설명을 할 수 있다.이번에는 fdisk명령으로 설정해 보려 한다.아치위키의 설명에 따르면 아래 표처럼 파티션을 설정하는것을 제안하고 있다. Mount point Partiton Partition Type Suggested size /mnt/boot /dev/efi_system_partition EFI system partition At least 300 MiB [SWAP] /dev/swap_partition Linux swap More than 512 MiB /mnt /dev/root_partition Linux x86-64 root (/) Remainder of the device 아래 명령을 통해 fdisk 명령으로 파티션을 설정 할 수 있다.# 현재 인식되는 저장장치 및 파티션 표시fdisk -l# fdisk 명령 모드로 진입fdisk /dev/the_dist_to_be_partitioned# 명령어 확인m# 아래 과정으로 파티션 설정과정 수행전체 디스크 포맷을 위해 g 입력 (전체 데이터를 지우고 싶지 않으면 생략 ex: 듀얼부팅)또는 d를 입력해 불필요한 파티션 삭제첫 파티션 생성을 위해 n 입력첫번째 파티션이므로 엔터용량 입력으로 EFI 파티션은 보통 512MB로 설정하므로 +512M 입력파일 시스템 변경을 위해 t입력첫번째 파티션을 변경하는 것이므로 1입력L 로 파티션 타입 번호를 확인EFI 시스템 파티션이므로 1입력위와 비슷한 방법으로 swap 파티션 설정나머지는 그래로 진행하되 용량은 원하는 용량 입력파티션 타입은 linux swap 파티션이므로 19 입력(swap 파티션 용량은 과거에는 RAM 용량의 두배를 설정하는게 보통이었지만 현재는 원하는 값으로 해도 무방 심지어 설정 안해도 된다.)마지막으로 위의 방법으로 root 파티션 생성남은 용량 전체를 설정하고 싶으면 용량을 입력하지 않고 엔터w로 파티션 설정 저장q로 fdisk명령 종료Partition 포맷이제 파티션 설정을 모두 끝냈으니 파티션 들을 포맷해줘야 한다.리눅스에서는 mkfs 명령으로 파티션을 원하는 타입으로 포맷할 수 있다.우선 아래 명령으로 EFI 시스템 파티션을 포맷할 수 있다.mkfs.fat -F 32 /dev/efi_system_partition다음으로 아래 명령으로 linux swap 파티션을 포맷 할 수 있다.mkswap /dev/swap_partition마지막으로 아래 명령으로 ext4 형식으로 루트 파티션을 포맷 할 수 있다.mkfs.ext4 /dev/root_partition -L arch_os -L은 파티션 라벨을 추가하는 옵션이다.Mount 파일 시스템이제 파티션 설정이 끝났다!!파티션을 마운트하여 접근 할 수 있도록 해야한다.우선 루트 파티션을 아래 명령으로 마운트 한다.mount /dev/root_partition /mnt다음으로 EFI 시스템 파티션을 루트 파티션 아래에 마운트 해준다.cd /mntmkdir bootmount /dev/efi_system_partition /mnt/boot참고로 EFI 시스템 파티션을 마운트하는 위치는 몇가지 다른 옵션이 있는데 관심 있다면 관련 문서를 참고하면 된다.마지막으로 swap 파티션을 마운트 해준다.swapon /dev/swap_partitionMirrorlist 설정아치 리눅스를 패키지를 여러 미러서버들을 통해 다운받을 수 있다. 설치용 미디어 환경에서는 인터넷 연결이 확이되는 순간 20여개의 미러서버들을 속도순으로 정렬해준다.하지만 우리나라에서 사용하기에는 모두 해외에 서버가있어 속도가 느리므로 수동으로 설정하면 조금더 빠르게 패키지들을 설치할 수 있다. 따라서 아래 설명을 따라 미러서버를 설정해주는 것을 추천한다.우선 Pacman Mirrorlist Generator에 들어가면 한국 서버들의 리스트를 확인할 수 있다.미러서버 설정은 매우 간단한데 위의 링크에서 찾은 서버 목록을 /etc/pacman.d/mirrorlist 파일에 입력해주면 된다. 서버 리스트에는 Server 앞에 # 주석이 적혀있는데 주석은 지워줘야 한다!Base 패키지 및 kernel 설치드디어 가장 메인인 아치 리눅스 커널과 기본 패키지를 설치할 차례이다!!pacstrap 명령어를 통해 매우 기본적인 아치 리눅스 커널과 기본 패키지를 설치 할 수 있다.pacstrap /mnt base linux linux-firmware다만 위의 명령어는 미니멀리즘한 배포판 답게 매우 기본적인 기능밖에 없다. 따라서 아치위키 설명을 참고하여 글쓴이는 좀더 추가적인 패키지들도 같이 설치하고자 한다.또한 리눅스 커널은 기본 커널이 아닌 linux-zen 커널을 설치할 것이다. 이는 조금 개조된 리눅스 커널로 이전에 valve의 게임 최적화 패치를 빠르게 업데이트 하기도 하였고 waydroid와 같은 프로그램을 쓰기위한 기능들도 일부 포함되어 있기 때문이다.커널 종류들은 kernel 문서를 참고하면 좋다.따라서 글쓴이는 아래와 같이 커널과 기본 패키지들을 설치하였다.pacstrap /mnt base linux-zen linux-zen-headers linux-firmware base-devel vim networkmanager man-db man-pages texinfo dosfstools mdadm lvm2이 이상의 패키지는 chroot 이후에 설치할 예정이다.Fstab다음으로 fstab 파일을 생성해야 한다. fstab 이란 파일 시스템 테이블로 리눅스의 파일 시스템에 대한 정보를 저장하는 파일이다.아래 명령으로 현재 마운트된 파일 시스템을 기반으로 테이블을 생성할 수 있다.genfstab -U /mnt &gt;&gt; /mnt/etc/fstabChroot이제 설치한 시스템으로 진입할 수 있다!!이래 명령어를 입력한다.arch-chroot /mntTime zone새로 설치한 시스템을 위한 설정을 몇가지 해줘야 한다.우선 아래 명령으로 시간대 설정을 할 수 있다.ln -sf /usr/share/zoneinfo/Asia/Seoul /etc/localtime다음으로 아래 명령으로 하드웨어 시간도 동기화 해줄 수 있다.hwclock --systohc좀더 추가적인 정보는 timezone 문서와 이전 포스트 참고하자.Localizaion다음으로 언어 설정을 해주어야 하는데 /etc/locale.gen 파일에서 사용할 언어들의 주석을 제거해주면 된다.글쓴이의 경우 en_US.UTF-8 UTF-8와 ko_KR.UTF-8 UTF-8 두개의 주석을 제거했다.파일 편집이 끝나면 다음 명령을 입력한다.locale-gen마지막으로 /etc/locale.conf 파일을 아래처럼 작성한다.LANG=en_US.UTF-8 글쓴이의 경우 리눅스 시스템 기본 언어를 한국어로 설정하면 충돌 등의 문제가 우려되 영어로 설정하였다.Network 설정네트워크 설정 또한 해주어야 하는데 /etc/hostname 파일을 생성해 원하는 호스트네임을 적어주면 된다.myhostname또한 위의 pacstrap 명령으로 설치한 NetworkManager가 자동 실행되도록 아래 명령을 입력한다.systemctl enable NetworkManager.service비밀번호 설정아래 명령으로 root 계정의 비밀번호를 설정할 수 있다.passwd사용자 계정 추가아치위키의 관련 문서에 따르면 root 계정만을 사용하는 것은 보안상 좋지 않다고 하므로 사용자 계정을 추가해주어야 한다.useradd -m -g users -G wheel -s /bin/bash username wheel 그룹에 사용자를 추가하는 이유는 sudo 명령을 사용가능하게 하기 위함이다.사용자 계정 비밀번호는 아래 명령으로 설정한다.passwd userSudo 설정기본 설정으로는 sudo 명령을 사용할 수 없으므로 sudo 사용을 설정해주어야 한다.아래 명령을 입력하면 vi 편집기 모드로 sudo 설정 파일을 수정할 수 있다.visudosudo 설정파일에서 아래로 내리다 보면 ## Uncomment to allow members of group wheel to execute any command라고 적힌 부분이 있는데 해당부분 아래의 주석을 아래처럼 제거해주면 된다.## Uncomment to allow members of group wheel to execute any command%wheel ALL=(ALL) ALLMicrocode (optional)CPU 제조사들은 CPU의 보안 이슈가 발생하면 이에대한 소프트웨어 패치를 microcode라는 이름으로 배포한다.이를 설치하지 않아도 무방하지만 보안을 조금더 신경쓰고 싶다면 아래 명령으로 설치하도록 하자.pacman -S amd-ucode # AMD CPU인 경우pacman -S intel-ucode # Intel CPU인 경우이러한 패키지의 로딩은 부트로더에서 설정하므로 아래 부트로더 항목에서 설명했다.Boot loader 설정아직 부팅을 위한 부트로더를 설정하지 않았다. systemd에 기본으로 포함되어 있는 systemd-boot로 부트로더를 설정할 수 있다.아래 명령으로 EFI 시스템 파티션에 systemd-boot를 설치할 수 있다.bootctl install다음으로 /boot/loader/loader.conf를 설정해 주어야 한다.글쓴이의 경우 아치위키에 나와있는대로 아래와 같이 설정하였다.default arch.conftimeout 4console-mode maxeditor no다음으로 부팅시의 진입점을 설정해 주어야 한다. /boot/loader/entries/arch.conf 파일을 생성해 아래와 같이 입력해 준다. 위의 microcode를 설치했다면 ucode 부분을 꼭 추가하도록 한다.title Arch Linuxlinux /vmlinuz-linux-zeninitrd /amd-ucode.img # 위의 microcode를 설치했을 때로 intel인 경우 amd를 intel로initrd /initramfs-linux-zen.imgoptions root=\"LABEL=arch_os\" rw또한 추가적으로 /boot/loader/entries/arch-fallback.conf 파일을 생성해 아래와 같이 입력해 준다.title Arch Linux (fallback initramfs)linux /vmlinuz-linux-zeninitrd /amd-ucode.img # 위의 microcode를 설치했을 때만 intel인 경우 amd를 intel로initrd /initramfs-linux-zen-fallback.imgoptions root=\"LABEL=arch_os\" rw 만약 듀얼부팅 환경이라면 윈도우 부팅 매니저는 수동으로 추가하지 않아도 자동으로 추가해 준다!Initramfs (optional)보통의 경우에는 mkinitcpio명령이 커널을 설치할 때 자동으로 실행되기 때문에 필요없지만 LVM, system encryption, RAID 등의 설정을 할때는 mkinitcpio.conf파일을 수정하기 때문에 새로 initramfs를 생성해줘야 한다.initramfs 생성은 아래 명령을 실행하면 된다.mkinitcpio -P마운트 해제 및 재부팅이제야 기본적인(?) 아치 리눅스 운영체제 설치가 끝났다.아래 명령으로 시스템 환경에서 나갈수 있다.exit다음으로 마운트 했던 저장장치들을 모두 해제한다.umount -lR /mnt이제 설치 미디어가 아닌 설치된 아치 리눅스로 재부팅 할 수 있다!reboot이제 아치 리눅스 설치용 USB 드라이브는 분리해도 된다.아치 리눅스에 오신걸 환영합니다!!!추가 권장 패키지 설치열심히 설치한 아치 리눅스로 부팅하였지만 아직 GUI도 없고 인터넷 브라우저와 같은 필수적인 응용프로그램이 설치되어있지 않다.따라서 아주 기본적인 몇가지만 설치하는 방법을 설명하고자 한다.우선 여러 패키지들을 다운받으려면 인터넷이 필요하니 인터넷 연결을 확인 한다.ping -c 3 archlinux.orgWi-Fi 연결 (optional)유선 네트워크를 사용할 수 없는 환경이라면 Wi-Fi에 연결해야 한다. 위의 설치에서 Network Manager를 설치했으니 아래 명령어로 Wi-Fi에 연결 할 수 있다.nmtui명령어를 입력하면 터미널 기반의 UI로 편하게 Wi-Fi에 연결 할 수 있다. 방향키로 커서를 이동할 수 있고 Activate connection을 선택하면 주변 Wi-Fi를 확인할 수 있고 Activate로 연결할 수 있다.패키지 업데이트우선 다른 패키지를 다운받기 전에 설치된 패키지들을 모두 없데이트 해준다. 아치 리눅스 기본 패키지 매니저인 pacman에서는 아래 명령어로 업데이트를 할 수 있다.sudo pacman -Syu그래픽 드라이버 설치현재의 CLI 환경에서도 많은 작업을 할 수는 있겠지만 아무래도 그래픽 환경이 있는게 편하다. 이런 그래픽 환경을 사용하기 위해서는 그래픽 카드를 잘 작동 시킬수 있도록 그래픽 드라이버를 먼저 설치해 주어야 한다.그래픽 드라이버에 대한 설명은 Intel Graphics, AMDGPU, Nvidia에서 확인할 수 있다.설치 명령을 정리하면 아래와 같다.# Intelsudo pacman -S mesa xf86-video-intel vulkan-intel# AMDsudo pacman -S mesa xf86-video-amdgpu vulkan-radeon# Nvidiasudo pacman -S nvidia# Nvidia with custom kernelsudo pacman -S nvidia-dkms추가로 커널 모드 설정을 해주어야 하는데 /etc/mkinitcpio.conf파일을 수정해주어야 한다. 자세한 설명은 kernel mode setting 문서를 확인하면 된다.간단하게 정리하면 아래와 같다.# IntelMODULES=(... i915 ...)# AMDMODULES=(... amdgpu ...)# NvidiaMODULES=(... nvidia nvidia_modeset nvidia_uvm nvidia_drm ...)파일 수정이 끝난 뒤에는 initramfs를 아래 명령어로 다시 생성해 주어야 한다.mkinitcpio -PNvidia의 경우 커널 파라미터도 설정해 주어야 하는데 /boot/loader/entries/arch.conf파일에서 options를 아래와 같이 파라미터를 추가해준다.options root=\"LABEL=arch_os\" rw nvidia-drm.modeset=1또한 Nvidia의 경우 initramfs도 업데이트 해줘야 하는데 pacman hook을 사용하면 이를 자동화할 수 있다.이를 위해서는 /etc/pacman.d/hooks/nvidia.hook경로에 파일을 만들고 아래 내용을 저장해주면 된다.[Trigger]Operation=InstallOperation=UpgradeOperation=RemoveType=PackageTarget=nvidia-dkmsTarget=linux-zen# Change the linux part above and in the Exec line if a different kernel is used[Action]Description=Update Nvidia module in initcpioDepends=mkinitcpioWhen=PostTransactionNeedsTargetsExec=/bin/sh -c 'while read -r trg; do case $trg in linux-zen) exit 0; esac; done; /usr/bin/mkinitcpio -P' 위 내용에서 linux-zen과 nvidia-dkms는 자신이 설치한 패키지 이름으로 설정해 줘야 한다.데스크탑 환경 설치데스크탑 환경(Desktop Environment)란 리눅스에서 GUI 환경 패키지 세트쯤 된다고 생각하면 된다.아치위키 문서에서도 확인할 수 있듯이 리눅스에는 매우 다양한 데스크탑 환경이 있는데 유명한것으로는 GNOME, KDE, Xfce가 있다.여기서는 글쓴이가 개인적으로 좋아하는 한국에서는 그놈이라 쓰는 GNOME을 기준으로 설명한다. 우선 gnome 패키지를 설치해 준다.sudo pacman -S gnome위 명령어를 입력하면 다양한 GNOEM 소프트웨어들을 선택하라 하는데 그냥 엔터를 누르면 기본값으로 설치된다.설치를 완료하였다면 재부팅시 자동으로 실행되게 해야하는데 systemctl 명령을 사용한다.sudo systemctl enable gdm한글 설정아치 리눅스는 기본적으로 서방에서 많이 사용하다보니 한글 폰트나 한글 입력기가 기본적으로 설치되어 있지 않다. 따라서 몇가지 설정을 해주어야 하는데 자세한건 Localization/Korean 문서를 확인하면 된다.아래 설명은 글쓴이의 취향에 기반해 있다.# 폰트 설치sudo pacman -S noto-fonts noto-fonts-cjk noto-fonts-emoji noto-fonts-extra# 한글 입력기 설치sudo pacman -S ibus-hangul입력기를 설치 후에는 관련 설정또한 해주어야 하는데 /etc/environment파일을 아래와 같이 입력해주면 된다.GTK_IM_MODULE=ibusQT_IM_MODULE=ibusXMODIFIERS=@im=ibusAUR helper 설치아치 리눅스에는 AUR(Arch User Repository)라는 아치 유저들이 관리하고 있는 유저 레포지토리가 있다. 어디까지나 ‘유저’ 레포지토리인 만큼 악성코드가 있다거나 문제가 있는 패키지가 있던 경우도 있으나 유명하고 활성화된 패키지들 또한 많다.그리고 악성코드의 경우 ‘PKGBUILD’를 꼼꼼히 확인하는 등의 약간의 수고를 들이면 충분히 안전하게 사용할 수 있다. 다만 이러한 AUR을 그냥 사용하기엔 약간의 불편함이 있어 이를 도와주는 AUR helper를 설치하는 방법에 대해 설명하고자 한다.아래 방법은 AUR 패키지의 메뉴얼 한 설치 방법이기도 하므로 수동 설치가 관심 있으면 참고해도 좋다. 여기서는 가장 유명한 AUR helper인 yay를 설치한다.yay는 AUR에 업로드 되어 있으므로 우선 이 패키지 파일을 다운받아야 하므로 git을 설치하고 다운받아 준다.# git 설치sudo pacman -S git# git으로 yay 가져오기git clone https://aur.archlinux.org/yay.git이제 다운이 다 됬으므로 아래 명령어들을 입력해 설치해준다.# yay 디렉토리 진입cd yay# 패키지 설치makepkg -riscSecure boot 설정 (optional)위의 부팅전에 secure boot 설정을 껐지만 앞으로 다시 켜서 사용하고 싶을 경우 secure boot 설정을 해주어야 한다.Secure boot 설명 문서에 여러 방법들이 나와있는데 이중 구글에 검색해봤을때 가장 유명했던 shim을 기준으로 설명하고자 한다.shim은 AUR에 업로드되어 있으므로 아래 명령으로 설치해준다. 추가로 efibootmgr 또한 필요하므로 설치해준다.yay shim-signedyay -S efibootmgryay등의 AUR helper로 설치한 뒤에도 몇가지 파일들을 복사 해주어야 하는데 아래 명령어들을 입력해주면 된다.# 우선 BOOTx64.EFI를 grubx64.efi로 이름을 바꿔준다.mv /boot/EFI/BOOT/BOOTx64.EFI /boot/EFI/BOOT/grubx64.efi# 두개의 파일을 복사해 준다.cp /usr/share/shim-signed/shimx64.efi /boot/EFI/BOOT/BOOTx64.EFIcp /usr/share/shim-signed/mmx64.efi /boot/EFI/BOOT/# shim으로 부팅될수 있도록 부팅 진입점을 새로 efibootmgr 명령을 사용해 생성해준다.efibootmgr --verbose --disk /dev/sdX --part Y --create --label \"Shim\" --loader /EFI/BOOT/BOOTx64.EFI efibootmgr 명령에서 --disk /dev/sdX 부분은 자신의 저장장치 경로에 맞게 설정해주고(파티션 번호 제외) --part Y 부분에서 Y대신 파티션 번호를 설정해준다.이제 모든 설치가 끝났으니 재부팅해주면 된다!다만 shim은 부트 이미지들에 해쉬값을 생성해주어야 하는데 이는 재부팅 과정에서 진행할 수 있다.재부팅을 하게되면 MokManager라는 것이 실행되게 되는데 여기서 Enroll hash를 선택해준뒤 /boot/EFI/BOOT/grubx64.efi파일을 선택해 해쉬를 생성해준다. 또한 vmlinuz-linux-zen 파일을 찾아 한번더 해쉬를 생성해주면 된다. 이러한 해쉬 생성은 shim이나 커널이 업데이트 되어 파일이 변경되었을때 다시 해주면 된다.이것으로 Secure Boot까지 기본적인 설정들은 모두 마치게 된다!!추가로 참고할 자료이 이상의 설정은 이미 위에서 설정한것도 몇가지 있지만 아치위키의 General recommendations 문서를 참고하면 좋다. 또한 아치 리눅스에서 사용할만한 응용프로그램에 대해서는 List of applications 문서도 참고하면 좋다.아치 리눅스에대한 많은 정보는 아치위키에 정말 잘 정리되어 있으니 뭔가 문제가 생기거나 하면 꼭 확인해 보는것이 좋다." }, { "title": "윈도우에서 패키지 관리자를 사용해보자!(winget)", "url": "/posts/%EC%9C%88%EB%8F%84%EC%9A%B0%EC%97%90%EC%84%9C-%ED%8C%A8%ED%82%A4%EC%A7%80-%EA%B4%80%EB%A6%AC%EC%9E%90%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%B4%EB%B3%B4%EC%9E%90!-(winget)/", "categories": "Windows, Installation and Configuration", "tags": "windows, package manager, winget", "date": "2022-03-03 16:30:00 +0900", "snippet": "리눅스 운영체제를 사용하다보면 대부분의 배포판에 패키지 관리자(apt, pacman)가 설치되어있어 매우 편하게 프로그램들을 설치 및 관리할 수 있다.이러한 기능들을 윈도우에서도 사용하는 방법에 대해 적어보고자 한다.wingetWinget은 마이크로소프트에서 개발한 윈도우용 패키지 관리 프로그램이다.Winget 이전에는 chocolatey 등의 3rd 파티 프로그램을 사용하거나 해야했지만 이제 마이크로소프트에서 공식 제공하는 패키지 관리 프로그램을 사용할 수 있게 되었다.이전에는 프리뷰밖에 존재하지 않아서 릴리즈 페이지에서 다운받았지만, 이제는 프러덕션 버전이 나왔다고 한다.마이크로소프트의 winget 공식 문서에 따르면 microsoft sotre에서 app installer를 업데이트 하면 된다고 한다.winget 사용법위의 설치가 끝났다면 powershell 이나 cmd 창을 열고 winget을 입력해보자.winget위와 같이 화면이 뜨면서 winget의 주요 명령어가 나오는것을 확인할 수 있다.위에 나온 설명을 기반으로 winget을 사용하면 되지만 몇가지 주요 명령어만 설명해 보고자 한다.winget 검색 명령winget search 명령을 사용하면 패키지 이름을 검색 해볼 수 있다.위와 같이 설치해보고자 하는 패키지 이름을 검색 할 수 있다.winget 설치 명령위와 같이 install 명령어를 사용해서 패키지를 설치 할 수 있다.다만 비슷한 패키지 이름이 있을때는 에러가 발생 할 수 있는데 이럴때는 패키지의 교유한 id를 사용해 설치해주면 된다.winget install --id Microsoft.VisualStudioCodewinget 제거 명령winget uninstall &lt;package name&gt;위와 같이 명령어를 입력하면 설치된 패키지를 제거할 수 있다.winget 업데이트 명령winget upgrade --all위와 같이 명령어를 입력하면 설치된 패키지들을 모두 최신 버전으로 업데이트 해준다.추가 정보winget에 대한 더욱 자세한 정보는 공식 문서를 참고해 보도록 하자." }, { "title": "리눅스에서 문명6 하기", "url": "/posts/%EB%A6%AC%EB%88%85%EC%8A%A4%EC%97%90%EC%84%9C-%EB%AC%B8%EB%AA%856-%ED%95%98%EA%B8%B0/", "categories": "Linux, Gaming", "tags": "linux, gaming", "date": "2022-02-19 14:50:00 +0900", "snippet": " 이 포스트는 본인의 예전 티스토리 블로그에 썼던글을 옮겨오면서 수정한 것이다.리눅스에서 문명 6가 네이티브로 돌아간다길래 깔아봤는데 몇 가지 문제가 있어 삽질 끝에 알아낸 내용을 정리해볼까 한다.문명6 실행시 문제우선 문명6는 네이티브로 리눅스를 지원하는 게임이므로 스팀에서 그냥 설치하면 된다.그러나 네이티브 지원이 무색하게 내 컴퓨터 환경(아치리눅스)에서는 실행에 문제가 있었는데, 게임 실행 버튼을 눌러도 아무런 창이 뜨지 않는 것이다.여러 삽질 끝에 해결방법을 알아냈는데 결론은 스팀에서 게임 설정을 수정해 주어야 한다.해결법아치위키 스팀 게임 문제해결 문서에 따르면 우선 스팀에서 ‘문명6-&gt;속성-&gt;일반’에 들어가 시작 옵션 값을 넣어주어야 한다.LD_PRELOAD='/usr/lib/libfreetype.so.6:/usr/lib/libbrotlicommon.so.1:/usr/lib/libbrotlidec.so.1' %command%시작 옵션으로 위의 값을 복붙해주면 된다.다음으로 ‘문명6-&gt;속성-&gt;호환’에 들어가 강제로 특정 호환 도구로 사용하기 옵션을 체크한뒤 ‘Steam Linux Runtime’으로 설정하면 된다. Steam Linux Runtime 이란?리눅스의 파편화된 배포판들에 상관없이 게임이 실행될 수 있도록 벨브에서 만든 리눅스 컨테이너 환경이다. 참고만약 Wayland 환경에서 문제가 있을 시위에 추가한 시작 옵션 앞에 아래 값을 추가해주면 된다. 이유는 문명의 게임 런처가 wayland를 지원하지 않기 때문이다.QT_QPA_PLATFORM=xcb참고https://www.pcgamingwiki.com/wiki/Civilization_VI#Game_datahttps://wiki.archlinux.org/title/Steam/Game-specific_troubleshooting#Civilization_VI" }, { "title": "듀얼부팅 환경에서 시간이 이상하게 나오는 문제", "url": "/posts/%EB%93%80%EC%96%BC%EB%B6%80%ED%8C%85-%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C-%EC%8B%9C%EA%B0%84%EC%9D%B4-%EC%9D%B4%EC%83%81%ED%95%98%EA%B2%8C-%EB%82%98%EC%98%A4%EB%8A%94-%EB%AC%B8%EC%A0%9C/", "categories": "Linux, Installation and Configuration", "tags": "linux, dual boot, system time", "date": "2022-02-18 16:30:00 +0900", "snippet": "듀얼부팅 환경으로 윈도우와 리눅스 운영체제를 설치하면 리눅스를 사용하다 윈도우를 사용하면 아래 작업표시줄에 표시되는 시간이 잘못 나오는 것을 확인 할 수 있다.이를 해결하는 방법에대해 알아보고자 한다.원인이에 대한 원인을 알아보기 위해 아치위키 System time과 위키백과 Real-time clock 문서를 참고해 봤다.운영체제는 부팅할때 메인보드로부터 시간에 대한 정보를 받아온다. 이러한 메인보드에 시간에 대한 정보를 갖고 있는 부분을 hardware clock, 또는 Real time clock(RTC) 이라고 하는데 이러한 시간은 localtime(현지시각) 또는 UTC(협정 세계시) 기준으로 저장된다고 한다.(최근의 UEFI 펌웨어는 시간대에 대한 정보도 담을 수 있다 한다)여기서 운영체제마다 기준이 달라서 듀얼부팅 환경에서 시간이 이상하게 나오는 경우가 발생하는데, 윈도우의 경우 localtime을 기준으로(MS-DOS 시절부터 localtime을 사용했기 때문에 호한성을 위해 남겨놨다고 한다. 링크 참고) 리눅스(워낙 다양한 버전과 배포판이 있는만큼 다를수 있다.)의 경우 UTC를 기준으로 hardware clock을 설정 한다고 한다.따라서 이러한 기준 설정을 하나로 통일해야 하는데 아래 두가지 방법이 있다.리눅스를 localtime을 사용하도록 설정하는 경우리눅스를 localtime을 사용하게 설정하기 위해서는 timedatectl 명령어를 사용하면 된다.timedatectl set-local-rtc 1다시 되돌리기 위해서는 숫자 1을 0으로 바꿔서 명령어를 입력하면 된다.다만 리눅스를 localtime을 사용하게 하면 아래 사진과 같이 경고를 확인 할 수 있고 아치위키에서도 예상치 못한 오류가 있을 수 있으니 윈도우를 UTC로 설정하는 것을 권장하고 있다.윈도우를 UTC를 사용하도록 설정하는 경우 (권장)윈도우를 UTC설정하는 것 또한 어렵지 않다.간단하게 윈도우에서 명령 프롬프트를 관리자 권한으로 실행한 다음 아래 명령어를 입력해주면 된다.reg add \"HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\TimeZoneInformation\" /v RealTimeIsUniversal /d 1 /t REG_DWORD /f아치위키에 따르면 위의 설정 후 hardware clock 업데이트가 필요할 수도 있다고 하니 다시 리눅스로 돌아가 아래 명령어로 업데이트 해주도록 하자. 참고sudo hwclock --systohc추가로 참고할만한 자료https://help.ubuntu.com/community/UbuntuTime#Multiple_Boot_Systems_Time_Conflicts" }, { "title": "리눅스 듀얼부팅을 위해 윈도우 EFI 시스템 파티션(ESP) 설정하기 (w/ Arch Linux)", "url": "/posts/%EB%A6%AC%EB%88%85%EC%8A%A4-%EB%93%80%EC%96%BC%EB%B6%80%ED%8C%85%EC%9D%84-%EC%9C%84%ED%95%B4-%EC%9C%88%EB%8F%84%EC%9A%B0-EFI-%EC%8B%9C%EC%8A%A4%ED%85%9C-%ED%8C%8C%ED%8B%B0%EC%85%98(ESP)-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0/", "categories": "Linux, Installation and Configuration", "tags": "linux, windows, dual boot, esp, efi system partition", "date": "2022-01-29 13:30:00 +0900", "snippet": "(이미지 출처 : 위키백과)필요성아무리 리눅스를 위주로 쓰려해도 필연적으로 윈도우가 필요한 상황이 많이 있다. 특히, 게임을 한다든가, 마이크로소프트 오피스를 써야 한다던가, 인터넷 뱅킹을 해야한다거나 등등 아예 윈도우 없이 살기는 힘든게 사실이다.결국 윈도우 운영체제가 설치된 pc가 하나쯤은 필요한데, 두개의 컴퓨터를 구매하기에는 경제적 부담이 큰 관계로 하나의 컴퓨터에 두개의 운영체제를 깔아쓰는 듀얼부팅이 많이 쓰인다.글쓴이의 경우 현재 공부 및 개발용으로 아치 리눅스를 사용하고 게임 및 기타 프로그램용으로 윈도우를 사용하고 있다.듀얼부팅으로 운영체제를 설치하기에 앞서 아치 리눅스를 쓰는 만큼 아치위키의 듀얼부팅 항목을 읽어 보았다.듀얼부팅 항목을 읽어보니 듀얼 부팅을 위해서는 리눅스보다 윈도우를 먼저 설치하는 편을 추천 한다고 한다.또한 윈도우 부트로더보다 리눅스의 부트로더를 사용하는 편이 편하다고 한다.다만 여기서는 하나의 문제가 있을 수 있는데, 윈도우를 먼저 설치하는 경우 ESP(EFI System Partition)의 크기를 100MB로 자동 설정하게 된다.100MB의 ESP크기가 작은것은 아니지만 리눅스의 경우 여러가지 리눅스 커널을 바꿔가며 사용할 수 있는데, 이럴경우 100MB의 크기는 부족할 수 있다고 한다. 따라서 이를 위해 윈도우 설치를 하기전에 ESP파티션을 충분한 크기로 먼저 설정할 필요가 있는데 이에대해 설명하고자 한다.준비아치위키의 설명에 의하면 ESP파티션의 크기를 아치 리눅스 설치 미디어로 설정할 수 있다. 이렇게하면 윈도우를 설치할때 이미 설정된 ESP를 사용하여 설치된다고 한다.이를 위해서는 우선 아치 리눅스 설치 미디어를 만들어야 한다. 아치 리눅스는 공식 다운로드 페이지에서 다운받을 수 있고 윈도우의 경우 Rufus, 리눅스의 경우 dd 명령어를 사용하는 방법으로 설치 미디어를 usb 드라이브 등에 만들수 있다. 자세한 방법은 연결된 링크로 들어가서 확인하자.ESP 설정이제 위에서 만든 아치 리눅스 설치 미디어를 사용해 부팅을 한다. 부팅을 시작하면 ‘Welcome to Arch Linux’가 뜨고 뭔가 메세지들이 주르륵 뜨면서 부팅이 실행된다. 부팅이 완료되면 명령창에서 커서가 깜박거리고 있을 거다.이제 파티션을 생성하는 명령어를 입력해야 한다. 우선 아래 명령어를 입력해 hdd나 ssd같은 저장장치들이 제대로 인식되는지 그리고 저장장치들의 경로를 확인 한다.fdisk -l저장장치들을 확인했으면 fdisk나 좀더 간단한 cfdisk 명령어를 사용해 파티션을 만들자.글쓴이의 경우 간단한 파티션 생성에는 cfdisk가 훨씬 직관적이라 생각해 cfdisk로 진행했다.cfdisk /dev/path위와 같이 저장장치의 경로와 함께 명령어를 입력하면 터미널 기반의 UI가진 화면이 뜰것이다. 여기서 아래 [New]를 클릭해 생성하기를 누르고 용량을 원하는 만큼 지정하면 된다.아치위키의 Installation Guide에 따르면 최소 300MB이상을 설정하는것을 권장한다 한다.글쓴이의 경우 대체로 많이들 설정하는 512MB로 설정했다. cfdisk화면상에서 ‘512M’ 으로 설정하면 된다.크기 설정을 한 후에는 Type을 설정해야 하므로 Type을 선택한뒤 EFI System(보통 맨위)을 선택한다.파티션 설정이 끝나면 Write를 선택에 설정한대로 쓰기작업을 하고 Quit로 화면을 나온다.이제 마지막으로 형식에 맞게 포맷을 해주어야 한다. 아치위키에 나온것처럼 포맷을 해준다.mkfs.fat -F 32 /dev/efi_system_partition모든 작업이 끝났으니 아래 명령어로 아치 리눅스를 종료한다.shutdown now운영체제 설치이제 모든 설정이 끝났다!윈도우 설치 미디어를 넣고 설치를 진행해보면 EFI System Partition이 시스템 파티션으로 자동으로 잡힌것을 확인할 수 있다. 이 파티션만 건드리지 않고 윈도우를 설치하면 된다.윈도우 설치가 끝나면 다음으로 리눅스를 설치해 듀얼부팅 환경을 구성해주면 된다. 리눅스 설치에 대한 글도 다음에 시간이 되면 작성할 예정이다." }, { "title": "개인 홈페이지 만들기(Github pages + Jekyll)", "url": "/posts/%EA%B0%9C%EC%9D%B8-%ED%99%88%ED%8E%98%EC%9D%B4%EC%A7%80-%EB%A7%8C%EB%93%A4%EA%B8%B0/", "categories": "Personal Homepage", "tags": "personal homepage, github pages", "date": "2022-01-16 13:30:00 +0900", "snippet": "평소 공부하다가 알게된 정보나 자료들을 Google Keep 메모에 정리해 두고는 했는데, 아무래도 길게 작성하기엔 좀 별로고 해서 개인 웹페이지를 만들어 기록하면 좋을것 같다는 생각이 들었다.홈페이지로 서비스형 블로그 등을 사용할까 고민하다 Github에 pages라는 기능을 사용해 웹호스팅을 하고 Jekyll이라는 static page generator를 사용해 홈페이지를 구축하게 되었다.PlatformGithub pages + JekyllGithub pages는 깃허브의 레포지토리를 정적 웹페이지용 웹서버로 사용할 수 있게 해주는 기능이다. 간단하게 html파일을 작성해 웹페이지를 만들 수 있지만 좀더 편하면서도 이쁘게 꾸미기 위해 정적 페이지 생성기(static page generator)를 알아보기로 했다.Jekyll, Hugo, Hexo 등 매우 다양한 페이지 생성기가 있는데, 그중 가장 유명한 Jekyll 사용하기로 했다. 또한 Github pages 내부적으로도 Jekyll을 사용한다고 하니 가장 호환이 좋을것 같았다.Chirpy Jekyll themeJekyll에서는 다양한 테마를 다운 받아 사용할 수 있다. 테마들에 대한 정보는 공식 사이트에 Resources 페이지에서 확인 할 수 있다.테마를 고르는데 있어서 여러가지 요소가 있지만, 홈페이지를 구축하는 이유가 정보나 자료들을 정리하기 위함이었던 만큼 카테고리 분류 기능이 있고 검색 기능이 있는것 위주로 찾아 보았다.여러 테마들을 비교해본 결과 Chirpy Jekyll Theme이 가장 마음에 들이 이것을 사용하기로 했다.InstallationRuby 개발 환경 설치Jekyll은 ruby를 사용하므로 이를 설치해야 한다.설치 방법은 공식사이트 Installation 문서에 잘 정리되어 있으므로 이를 참고하면 된다.글쓴이의 경우 Arch Linux를 사용하므로 Arch Wiki를 참고하여 다음과 같이 설치하였다.(운영체제마다 다르므로 주의!)sudo pacman -S rubyJekyll 설치이제 Jekyll을 설치해야 한다. Jekyll의 설치 방법 또한 셋업 페이지에 잘 정리되어 있으니 참고하면 된다.다만 위의 셋업 페이지에서는 사이트를 생성해보는 과정까지 나와있지만 여기서는 Chirpy 테마를 사용할 것이므로 Jekyll 설치까지만 진행 하도록 한다.gem install jekyll bundlerChirpy Jekyll Theme 적용Chirpy Jekyll Theme 깃허브 페이지에 가면 공식 설치 방법을 확인 할 수 있으니 참고하면 된다.우선 위 링크의 방법대로 Chirpy Starter 링크로 들어가 위 테마에서 제공하는 템플릿을 기반으로 내 레포지토리를 생성하면 된다.레포지토리 이름은 “[Uername].github.io”로 지으면 자동으로 Github pages 기능이 활성화 되게 된다. 자신만의 custom domain을 사용할 예정이라면 이름은 아무렇게나 지어도 된다.기본적인 설정 (_config.yml, about.md)우선 파일들을 수정하기 위해 아래 명령어로 레포지토리를 클론해 온다.git clone https://github.com/[Github_Username]/[Repository_Name].git레포지토리가 다운되었으면 레포지토리의 경로로 들어가 아래 명령어로 필수 패키지들을 다운 받는다.bundle글쓴이의 경우 webrick 패키지가 없다는 에러가 나와 아래 명령어로 설치해준뒤 다시 위의 명령어를 입력해 줬다.gem install webrickbundle이제 config 파일을 수정할 차례이다. 레포지토리의 root경로에 _config.yml이 있는데 이를 원하는데로 설정해 주면 된다. 각각의 설정마다 주석으로 설명이 되어 있기 때문에 설명을 읽고 수정하면 어렵지 않다.또한 _tabs 디렉토리에 about.md 파일이 있는데 이곳에 홈페이지 소개나 자기소개등의 내용을 입력해주면 된다. about 페이지는 홈페이지 좌측 메뉴에 about 탭을 눌렀을때 보여지는 페이지이다.Github pages 활성화레포지토리가 생성되면 레포지토리 페이지에서 setting -&gt; pages로 들어가 pages기능이 활성화 됬는지 확인한다. 만약 custom domain을 사용하기로 했다면 지금 custom domain을 설정해주면 된다.Custom domain 설정은 다음 링크를 참고하자. Managing a custom domain for your GitHub Pages sitepages가 활성화 되어 있다면 Source에서 브랜치를 gh-pages로 변경한다. 이유는 chirpy jekyll theme에 기본으로 설정되어 있는 github actions(커밋이 있을때 자동으로 실행되는 스크립트)가 gh-pages 브랜치에 생성된 페이지들을 저장하기 때문이다.Publish이제 기본적인 설정이 모두 끝났다!git push 명령으로 수정한 파일들을 push 해 보자. 우측에 environments를 보면 github-actions가 실행되는것을 확인 할 수 있다. 잠깐 기다렸다 [Uername].github.io 또는 본인이 설정한 custom domain으로 접속해 보면 접속이 되는것을 확인 할 수 있다!다음으로 참고할 것들이것으로 기본적인 웹페이지 제작 및 공개는 모두 끝났다. 몇가지 추가적인 세세한 설정이나 글쓰는 방법등은 chirpy-jekyll-theme 개발자가 만든 데모 페이지에 잘 정리되어 있으니 참고하여 자신의 홈페이지를 발전시켜 나가면 된다.또한 몇몇 Jekyll에 대한건 Jekyll 공식 문서를 참고하면된다." } ]
